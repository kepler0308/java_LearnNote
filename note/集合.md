# 集合

集合框架图

![](https://raw.githubusercontent.com/kepler0308/java_LearnNote/master/img/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%9B%BE.jpg)



## Collection接口：用于存储单个对象的集合

### 1、List接口

list接口的特点：

1、有序的，元素可以重复

2、允许多个Null元素

3、常用的有：ArrayList、Vector、LinkedList。

在实际开发中，应该考虑以下问题：

1、安全性问题

2、是否需要频繁的插入删除（LinkedList）

3、是否存储后遍历



#### ArrayList类

可调整大小的数组的实现List接口，使用方法如下：

```java
//在实际开发中，每个集合一般只存储一种数据类型
List<String> list = new ArrayList<>();

list.add("小赵");	//添加数据
list.add("小钱");
list.add("小孙");
list.add("小李");
//遍历集合，size如果不改变，一般在循环外读取，避免多次调用。
int size = list.size();
for(int i = 0;i < size;i ++) {
    System.out.println(list.get(i));
}

System.out.println(list.contains("小赵"));	//判断是否有某个元素
list.remove("小赵");				//删除某个元素

String[] array = list.toArray(new String[] {});	//转换为数组类型
```

ArrayList的特点是：

1、实现原理，采用动态对象数组实现，默认构造一个空数组

2、第一次添加元素，扩充容量为10，之后扩充数为：原来数组大小+原来数组大小的一半

3、不适合进行删除或插入操作

4、为了防止数组动态扩充次数过多，建议创建数组ArrayList时，给定初始容量

5、多线程中使用不安全，适合在单线程访问时使用，效率较高



#### Vector类

使用方法如下，和ArrayList类相似：

```java
Vector<String> v = new Vector<>();
v.add("小赵");	//添加数据
v.add("小钱");
v.add("小孙");
v.add("小李");

for(int i = 0;i < v.size();i ++) {
    System.out.println(v.get(i));
}
```

Vector类的特点：

1、实现原理，采用动态对象数组实现，默认构造一个大小为10的对象数组

2、扩充的算法，当增量为0时，扩充为原来大小的2倍，当增量大于0时，扩充为原来的大小+增量

3、不适合删除或插入操作

4、为了防止数组动态扩充次数过多，建议创建数组Vector时，给定初始容量

5、线程安全，适合在多线程访问时使用，在单线程使用效率较低。



#### LinkedList类

LinkedList是链表类，使用方法如下，三种List使用方法类似。

```java
LinkedList<String> list = new LinkedList<>();
		
list.add("小赵");	//添加数据
list.add("小钱");
list.add("小孙");
list.add("小李");

for(int i = 0;i < list.size();i ++) {
    System.out.println(list.get(i));
}
```

LinkedList的特点有：

1、实现原理，采用双向链表结构实现

2、适合插入，删除操作



### 2、Set接口

Set接口的特点是：

1、无序的（不保证顺序）

2、不允许重复元素

3、常用的实现类有：HashSet、TreeSet、LinkedHashSet



#### HashSet类

用法如下

```java
Set<String> set = new HashSet<>();
		
set.add("李白");
set.add("杜甫");
set.add("王维");
set.add("苏轼");
set.add("李白"); //因为String类型的原理，两个“李白”字符串地址相同，只会存储一个

//HashSet没有get()方法
String[] str = set.toArray(new String[] {});
for(String s:str) {
    System.out.println(s);
}
```

HashSet特点如下：

1、实现原理，基于哈希表（HashMap）实现

2、不允许重复，可以有一个NULL元素

3、不保证顺序恒久不变

4、添加元素时把元素当作HashMap的key存储，HashMap的value使用一个固定的Object对象



##### Tips1:排除重复元素方法：

当HashSet存储相同元素，如下：

```java
Cat c1 = new Cat("miaomiao",4,1);
Cat c2 = new Cat("xiaohua",5,2);
Cat c3 = new Cat("wangcai",3,3);
Cat c4 = new Cat("miaomiao",4,1);

Set<Cat> catset = new HashSet<>();
catset.add(c1);
catset.add(c2);
catset.add(c3);
catset.add(c4);

for(Cat c:catset) {
    System.out.println(c);
}
/*遍历输出，可以看到，c1和c4相同，但因为存储地址不同，hashcode值不同，HashMap判断为不同元素
Cat [name=wangcai, age=3, id=3]
Cat [name=miaomiao, age=4, id=1]
Cat [name=xiaohua, age=5, id=2]
Cat [name=miaomiao, age=4, id=1]
*/
```

HashMap（哈希表）的存储原理如下

![](https://raw.githubusercontent.com/kepler0308/java_LearnNote/master/img/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%BB%93%E6%9E%84.jpg)

hashCode是一个本地方法，它可以根据对象生成一组数据，N是HashMap数组长度，通过hashCode%N可以得到元素放的位置，如果两个元素hashCode%N相等，那么会以第一个元素为头部生成链表，如图d2，d3。



在java的集合中，判断两个对象相同的方法（假设两个对象A、B）：

```java
if(A.hashcode()==B.hashcode()){	//对象哈希值相等
    if(A.equals(B) == true){
       // 相等
        return true;
    }else{
        return false; //不等
    }
}else{
    return false; //不相等
}
```

所以为了让Cat类的对象c1 c4不重复存储，需要重写hashcode()和equals()方法 。在eclipse中可以快速添加这两种方法（在添加get和set方法那里）。之后就不会重复存储了。



#### TreeSet类

TreeSet类特点如下：

1、有序的，基于TreeMap（二叉树数据结构）实现，对象需要比较大小，通过对象比较器实现。

2、对象比较器还可以用来去除重复元素，如果是自定义的数据类，没有实现比较器接口，将无法添加到TreeSet集合中。

用法如下：

```java
//TreeSet类构造时需要添加比较器，否则无法添加元素。比较器可以单独写，也可以用lambda表达式。
TreeSet<Cat> tree = new TreeSet<>(new CatComparator());
//TreeSet<Cat> tree = new TreeSet<>((o1,o2)-> o1.getAge() - o2.getAge());

Cat c1 = new Cat("miaomiao",4,1);
Cat c2 = new Cat("xiaohua",4,2);
Cat c3 = new Cat("wangcai",3,3);
Cat c4 = new Cat("miaomiao",2,1);

tree.add(c1);
tree.add(c2);
tree.add(c3);
tree.add(c4);

for(Cat c:tree) {
    System.out.println(c.toString());
}
/*程序运行结果为如下，按照age元素的大小排序，当age相等时，TreeSet会认为是同一个元素。
Cat [name=miaomiao, age=2, id=1]
Cat [name=wangcai, age=3, id=3]
Cat [name=miaomiao, age=4, id=1]
*/
```



#### LinkedHashSet类

LinkedHashSet是由哈希表和链表实现，维护着一个运行于所有条目的双重链表，此链表定义了迭代顺序，即按照将元素插入set中的顺序（插入顺序）进行迭代。使用方法如下：

```java
LinkedHashSet<Cat> linkhash = new LinkedHashSet<>(); 
Cat c1 = new Cat("miaomiao",4,1);
Cat c2 = new Cat("xiaohua",4,2);
Cat c3 = new Cat("wangcai",3,3);
Cat c4 = new Cat("miaomiao",4,1);

linkhash.add(c1);
linkhash.add(c2);
linkhash.add(c3);
linkhash.add(c4);

for(Cat c:linkhash) {
    System.out.println(c.toString());
}
/*运行结果如下：按照添加顺序排序，因为之前重写了hashCode方法和equals方法，重复元素会不添加
Cat [name=miaomiao, age=4, id=1]
Cat [name=xiaohua, age=4, id=2]
Cat [name=wangcai, age=3, id=3]
*/
```



### 3、集合迭代

在java中，常用的迭代方法有以下：

1、Iterator		//JDK1.5前常用

2、ListIterator

3、Enumeration

4、foreach		//JDK1.5后常用



Iterator和foreach使用方法如下

```java
List<String> list = new ArrayList<>();
list.add("tom");
list.add("jack");
list.add("candy");
list.add("paul");

//Iterator方式进行遍历
Iterator<String> iter = list.iterator();
while(iter.hasNext()) {
    System.out.println(iter.next());
}
//ForEach方法遍历
for(String s:list) {
    System.out.println(s);
}

list.forEach((String s)->System.out.println(s));	//lambda表达式
```

