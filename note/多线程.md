# 多线程与并发

## 1、线程的基本使用

### 继承Thread类

通过继承Thread并重写run()方法完成：

```java
class MyThread extends Thread{
    public void run(){
        //执行任务
    }
}
//调用
MyThread t1 = new MyThread();
t1.start();	//执行线程
```



### 实现Runnable接口

通过实现Runnable接口完成

```java
class MyRunnable implements Runnable{
    public void run(){
        //执行任务
    }
}
//调用
MyRunnable mr = new MyRunnable();
Thread t2 = new Thread(mr);
t2.start();	//执行线程	
```



实现Runnable可以实现多个接口，而继承Thread方法则只能继承一个，所以实现接口的方法比较灵活。



## 2、线程的休眠

线程的休眠方法为：

```java
//休眠会使线程暂停，释放CPU的时间片。
Thread.sleep();		//静态方法，在哪个线程中调用即执行那个线程的休眠
```



## 3、join方法与中断线程

### join方法

join方法可以使当前线程暂停，等待调用join方法的线程执行完毕后继续执行：

```java
t1.join();      //等待t1线程执行完毕，再返回执行当前线程
```



### 中断线程

中断线程有两种方法，一种是使用interrupt()方法，一种是自定义标志的方法。自定义标志的方法比较简单方便一些。

#### interrupt()方法

```java
t1.interrupt();     //中断线程,并不直接中断，设置一个中断标志

class MyRunnable2 implements Runnable{
    @Override
    public void run() {
        for(int i = 0;i < 50;i ++){
            if(Thread.interrupted()){	//判断是否有中断标志，如果有，则跳出循环，相当于关闭线程
                break;
            }

            System.out.println(Thread.currentThread().getName()+"--"+i);
            try {
                Thread.sleep(300);
            } catch (InterruptedException e) {	//sleep模式下中断会抛出异常并清除中断标志
                e.printStackTrace();
                Thread.currentThread().interrupt();	//重新设置中断标志
            }
        }
    }
}
```

#### 自定义标志的方法

```java
MyRunnable3 ra2 = new Runnable3();
Thread t2 = new Thread(ra2);
t2.start();

ra2.flag = false;		//中断线程

class MyRunnable3 implements Runnable{
    public boolean flag = true;

    @Override
    public void run() {
        int i = 0;
        while(flag){	//判断自定义的标志，决定是否继续执行线程
            System.out.println(Thread.currentThread().getName()+"--"+(i++));
            try {
                Thread.sleep(300);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```



## 4、守护线程、优先级和其他方法

### 守护线程

当程序中唯一线程是守护线程时，会退出JVM

```java
t1.setDaemon(true);     //设置为守护线程
...						//当程序中只有守护线程t1运行，会退出java虚拟机
```



### yield()方法（不常用）

```java
Thread.yield();     //让出本次CPU执行时间片
```



### isAlive()

```java
Thread.isAlive()	//判断线程是否活跃（运行）
```



### 优先级设置

```java
t1.setPriority(Thread.MAX_PRIORITY);	//最大优先级	可以提高抢占CPU的概率
t1.setPriority(Thread.MIN_PRIORITY);	//最低优先级
t1.setPriority(Thread.NORM_PRIORITY);	//默认优先级
```